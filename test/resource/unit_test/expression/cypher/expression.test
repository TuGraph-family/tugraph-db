MATCH (n:Person {name:'Liam Neeson'}) RETURN n.birthyear, n.birthyear > 1900, n.birthyear > 2000;
MATCH (n:Person {name:'Liam Neeson'}) RETURN CASE WHEN n.birthyear < 1950 THEN 1 ELSE 2 END AS type /* 2 */;
MATCH (n:Person {name:'Liam Neeson'}) RETURN CASE WHEN n.birthyear < 1950 THEN 1 ELSE 2 END AS type1,CASE WHEN n.birthyear = 1952 THEN 1 ELSE 2 END AS type2 /* 2,1 */;
MATCH (n:Person {name:'Liam Neeson'}) RETURN CASE n.birthyear WHEN 1950 THEN 1 WHEN 1960 THEN 2 END AS type;
MATCH (n:Person {name:'Liam Neeson'}) RETURN CASE n.birthyear WHEN 1950 THEN 1 WHEN 1960 THEN 2 ELSE 3 END AS type;
MATCH (n:Person {name:'Liam Neeson'}) RETURN CASE n.birthyear WHEN 1952 THEN 1 WHEN 1960 THEN 2 ELSE 3 END AS type;
MATCH (n) RETURN CASE n.name WHEN null THEN false ELSE true END AS hasName;
OPTIONAL MATCH (n {name:'Liam Neeson'}) RETURN CASE n WHEN null THEN false ELSE true END AS hasN;
RETURN 2020;
RETURN 1+2+3-4;
RETURN 1+2 - (3+4);
RETURN 1+2*3;
RETURN (2+15)/2-3*8%10 /*4.5*/;
WITH 2 AS a,15 AS b RETURN (a+b)/a-a*b%4;
RETURN 2^3;
RETURN 2^3^2;
RETURN 2^(1+2)^2;
RETURN 2^(1+2)*3^2-51/(8%5) /*55*/;
RETURN 1+2.0+3+4.0;
RETURN 1+'a';
RETURN ['a']+'a';
RETURN 1+[1];
RETURN TRUE+[1.0];
RETURN NULL+'a';
RETURN 1+NULL;
RETURN 1.0-2+3.0;
RETURN NULL-1.1;
RETURN 1.0*2*3.0;
RETURN 1.0*NULL;
RETURN 1.0/2/3.0;
RETURN 1.0/NULL;
RETURN 5%3;
RETURN NULL%3;
RETURN 0^0;
RETURN null^3.0;
RETURN 0^null;
RETURN (2.0+1)*3-2/1.5+'a'+[1];
RETURN null^2*3/4+5-6;
MATCH (n) WHERE n.name STARTS WITH 'Li' RETURN n,n.name;
MATCH (n) WHERE n.name ENDS WITH 'Redgrave' RETURN n,n.name;
MATCH (n) WHERE n.name CONTAINS 'Li' RETURN n,n.name;
MATCH (n) WHERE n.name CONTAINS 'Redgrave' RETURN n,n.name;
MATCH (n) WHERE n.name CONTAINS 'on' RETURN n,n.name;
MATCH (n) WHERE n.name CONTAINS 'cha' RETURN n,n.name;
MATCH (n) WHERE n.name STARTS WITH 'Li&alonglongstring' RETURN n,n.name;
MATCH (n) WHERE n.name ENDS WITH 'on&alonglongstring' RETURN n,n.name;
MATCH (n) WHERE n.name CONTAINS 'on&alonglongstring' RETURN n,n.name;
MATCH (n) WHERE n.name REGEXP '.*' RETURN n.name;
MATCH (n) WHERE n.name REGEXP 'Li.*' RETURN n.name;
MATCH (n) WHERE n.name REGEXP '.*Redgrave' RETURN n.name;
MATCH (n) WHERE n.name REGEXP 'Houston.*' RETURN n.name;
MATCH (n) WHERE n.name REGEXP 'L.*on' RETURN n.name;
MATCH (n) WHERE n.name REGEXP '.*ee.*' RETURN n.name;
MATCH p = (n {name:'Rachel Kempson'})-[]->() RETURN p;
MATCH p = (n {name:'Rachel Kempson'})<-[]-() RETURN p;
MATCH p = (n {name:'Rachel Kempson'})-[]-() RETURN p;
MATCH p = (n {name:'Rachel Kempson'})-[]->()-[]->() RETURN p;
MATCH p = (n {name:'Rachel Kempson'})-[]->()-[]->(m) RETURN p,m;
MATCH p = (n {name:'Rachel Kempson'})-[]->()-[]-() RETURN p;
MATCH p = (n {name:'Rachel Kempson'})-[*1..2]->() RETURN p;
MATCH p = (n {name:'Rachel Kempson'})<-[*1..2]-() RETURN p;
MATCH p = (n {name:'Rachel Kempson'})-[*1..2]-() RETURN p;
MATCH p = (n {name:'Rachel Kempson'})-[*0..1]-() RETURN p;
MATCH p = (n {name:'Rachel Kempson'})-[*2..3]-() RETURN p;
MATCH p = (n {name:'Rachel Kempson'})-[*0..1]->()-[]->() RETURN p;
MATCH p = (n {name:'Rachel Kempson'})-[]->()-[]-() RETURN p,length(p);
MATCH p = (n {name:'Rachel Kempson'})-[*0..3]->() RETURN p,length(p);
MATCH (n) WHERE n.name IS NULL RETURN n,label(n);
MATCH (n) WHERE n.name IS NOT NULL RETURN n,label(n);
MATCH (n) WHERE n.name IS NOT NULL AND n.birthyear IS NULL RETURN n,label(n);
MATCH (n) RETURN n.name, CASE WHEN n.birthyear IS NULL THEN -1 ELSE n.birthyear + 10 END AS birth_10_years_later;
MATCH (n) WHERE exists(n.title) RETURN n.title,n;
MATCH (n) RETURN exists(n.name) AS has_name,exists(n.title) AS has_title,label(n);
MATCH (n) RETURN n,CASE exists(n.name) WHEN true THEN n.name ELSE n.title END AS content;
MATCH (n {name:'Rachel Kempson'}) RETURN exists((n)-[]->()) /*true*/;
MATCH (n {name:'Rachel Kempson'}) RETURN exists((n)-[]->(:Person)) /*true*/;
MATCH (n {name:'Rachel Kempson'}) RETURN exists((n)-[]->(:City)) /*false*/;
MATCH (n {name:'Rachel Kempson'}) RETURN exists((n)-[:MARRIED]->()) /*true*/;
MATCH (n {name:'Rachel Kempson'}) RETURN exists((n)-[:NO_TYPE]->()) /*false*/;
MATCH (n {name:'Rachel Kempson'}),(m {name:'Liam Neeson'}) RETURN exists((n)-[]->(m)) /*false*/;
MATCH (n {name:'Rachel Kempson'}),(m {name:'Liam Neeson'}) RETURN NOT exists((n)-[]->(m)) AS isNew /*true*/;
MATCH (n {name:'Rachel Kempson'}),(m {name:'Michael Redgrave'}) RETURN exists((n)-[]->(m)) /*true*/;
MATCH (n {name:'Rachel Kempson'}) RETURN exists((n)-[:MARRIED]->()-[]->()) /*true*/;
MATCH (n {name:'Rachel Kempson'}) RETURN exists((n)-[:MARRIED]->()-[:ACTED_IN]->()) /*true*/;
MATCH (n {name:'Rachel Kempson'}) RETURN exists((n)-[:MARRIED]->()-[:BORN_IN]->()) /*false*/;
MATCH (n {name:'Rachel Kempson'}) RETURN exists((n)-[*3]->()) /*true*/;
MATCH (n {name:'Rachel Kempson'}) RETURN exists((n)-[:MARRIED*3]->()) /*false*/;
MATCH (n {name:'Rachel Kempson'}) RETURN exists((n)-[:MARRIED|HAS_CHILD*3]->()) /*true*/;
MATCH (n {name:'Rachel Kempson'}),(m:Person) RETURN exists((n)-[]->(m)) /*3 true*/;
MATCH (n {name:'Rachel Kempson'}),(m:Person) RETURN exists((n)-[:MARRIED]->(m)) /*1 true*/;
# VisitedEdges An added edge cannot be removed from a combination of limit + expand_all operators,fix in the future
#MATCH (n {name:'Rachel Kempson'}),(m:Person) RETURN exists((n)-[:MARRIED]->()-[]->(m)) /*3 true*/;
MATCH (n {name:'Rachel Kempson'}),(m:Person) RETURN exists((n)-[:HAS_CHILD]->()-[]->(m)) /*2 true*/;
MATCH (n {name:'Rachel Kempson'}),(m:City) RETURN exists((n)-[:HAS_CHILD]->()-[:BORN_IN]->(m)) /*1 true*/;
MATCH (n:Person)-[:BORN_IN]->(c) WHERE exists((n)-[:HAS_CHILD]->()-[:BORN_IN]->(c)) RETURN n,c;
RETURN [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] AS list;
WITH [1,3,5,7] AS a RETURN a;
RETURN range(0, 4), range(2, 18, 3) /* [0,1,2,3,4],[2,5,8,11,14,17] */;
RETURN range(0, 10)[3];
RETURN range(0, 10)[-3] /* 8 */;
RETURN range(0, 10)[15];
RETURN range(0, 10)[0..3];
RETURN range(0, 10)[0..-5] /* [0,1,2,3,4,5] */;
RETURN range(0, 10)[3..3] /* [] */;
RETURN range(0, 10)[3..1] /* [] */;
RETURN [1,2,3,4,5]+[6,7] AS myList;
WITH [1,2,3,4,5] AS l1, [6,7] AS l2 RETURN l1+l2 AS myList;
MATCH (n:City) RETURN collect(n.name)+['Wuhan'] AS cNames;
UNWIND [2, 3, 4, 5] AS number WITH number WHERE number IN [2, 3, 8] RETURN number;
RETURN date('2017-05-03');
RETURN date('2017-05-01');
RETURN date('2017-05-01') < date('2017-05-03');
RETURN date('2017-05-03') > date('2017-05-01');
RETURN date('2017-05-01') = date('2017-05-01');
RETURN datetime('2017-05-03 10:40:32') AS timePoint;
RETURN datetime('2017-05-01 10:00:00') > datetime('2017-05-03 08:00:00');
RETURN datetime('2017-05-01 10:00:00') < datetime('2017-05-03 08:00:00');
RETURN datetime('2017-05-01 10:00:00.000001') > datetime('2017-05-01 10:00:00');
RETURN datetime('2017-05-01 10:00:00.000002') > datetime('2017-05-01 10:00:00.000001');
WITH datetime('2017-05-01 10:00:00') AS t1, datetime('2017-05-03 08:00:00') AS t2 RETURN t1>t2,t1<t2;
WITH true AS bt, false AS bf RETURN bt = false, bf = false, bt <> bf;
RETURN bin('MjAyMAo=') > bin('MjAxOQo=');
RETURN bin('MjAyMAo=') < bin('MjAxOQo=');
RETURN bin('MjAyMAo=') = bin('MjAyMAo=');
WITH bin('MjAyMAo=') AS bin1, bin('MjAxOQo=') AS bin2 RETURN bin1>bin2,bin1<bin2;
RETURN dateComponent(12345, 'year'), datetimeComponent(12345, 'month'), datetimeComponent(12345, 'day');
RETURN datetimeComponent(1582705717, 'year'),datetimeComponent(1582705717, 'month'),datetimeComponent(1582705717, 'day');
RETURN datetimeComponent(1582705717, 'hour'),datetimeComponent(1582705717, 'minute'),datetimeComponent(1582705717, 'second'), datetimeComponent(1582705717, 'microsecond');
RETURN datetimeComponent(1582705717000, 'year'),datetimeComponent(1582705717000, 'second'), datetimeComponent(1582705717000, 'microsecond');